{"config":{"lang":["en"],"separator":"[\\s\\-\\.\\_]+","pipeline":["stopWordFilter"]},"docs":[{"location":"day1/cg_basics/","title":"1. Basics of Computer Graphics","text":""},{"location":"day1/cg_basics/#11-pixels","title":"1.1. Pixels","text":"<p>A pixel, or picture element, is the smallest part of a screen or image that can light up independently from any other part of the screen. Each screen or image has a resolution, i.e. the number of pixels that is has in each direction. For instance, a screen resolution of 1920x1080 means that the screen has 1920 pixels in the X direction and 1080 pixels in the Y direction.</p> <p>Here is an image of my laptop screen that I took from my phone camera at full zoom, and you can see the grid of pixels.</p> <p> </p>"},{"location":"day1/cg_basics/#12-colour","title":"1.2. Colour","text":"<p>A pixel consists of three sub pixels, A red, green and blue sub pixel. You can actually see this in the image above. It turns out, that most colours that the human eye can see can be made by just mixing red green and blue light together. For instance, on a digital screen, if you're looking at something white, it actually is red, green and blue light all mixed together. In the image above, you can see the white bracket has all of its sub pixels lit up.</p> <p>Each sub pixel can have 255 different levels of brightness, ranging from 0 to 255 (both inclusive). These shades are shown below:</p> <p> </p> <p>Thus, for every pixel, there are \\(256^3\\) different possible combinations of colours that it can have.</p> <p>This combination of red, green and blue values that make up the colour of the pixel is known as the RGB value of that pixel.</p> <p>There is a special case for the RGB value of a pixel, where all three brightness levels are equal. When this happens, the pixel shows a shade of grey. This value is simply referred to as the greyscale value of the pixel</p> <p> </p> <p>There is one more component of colour that can modify what a pixel looks like - transparancy. The transparancy value also ranges from 0-255, where 0 is fully transparant and 255 is fully opaque. The red square in both images has an alpha value of 255 (fully opaque) but the blue square in the left image has an alpha value of 150 (more opaque) and the blue square in the right image has an alpha value of 50 (more transparent)</p> <p> </p> <p>All of these four numbers, red, green, blue and alpha are collectively referred to as the RGBA value</p>"},{"location":"day1/cg_basics/#13-coordinates","title":"1.3. Coordinates","text":"<p>To be able to draw anything on the screen, we want to be able to specify a position for it. For this reason, each pixel on the screen has some coordinates associated with it. These coordinates are represented in the Cartesian coordinate system. Conventionally, the coordinate system has its origin in the \"centre\" of the plane, but with computers, its slightly different. The origin, (0, 0), is at the top left of the screen and the positive X direction is towards the right and the positive Y direction is towards the bottom.</p> <p> </p> <p>The reason for this confusing difference is because early monitors were all CRT monitors, that drew each frame pixel by pixel from left to right and top to bottom. This made it easier to just have (0, 0) at the top left. This is an intersting video to watch if you want to learn more about how CRT monitors work:</p> <p> </p>"},{"location":"day1/intro/","title":"Introduction","text":""},{"location":"day1/intro/#what-is-p5","title":"What is p5?","text":"<p>p5 is javascript creative coding/animations library that aims to make coding easily accessible to everyone.</p> <p>website: https://p5js.org/</p> <p>It is an equivalent of processing that was made for the Java programming language all the way back in 2001.</p> <p>What you can do with p5 and processing:</p> <p>http://www.generative-gestaltung.de/2/ https://openprocessing.org/browse/#</p>"},{"location":"day1/objects/","title":"Objects","text":""},{"location":"day1/objects/#51-what-is-object-oriented-programming-why-do-we-need-it","title":"5.1. What is Object Oriented Programming? Why Do We Need It?","text":"<p>We come across a lot of different objects in our daily life. Each object has its own properties, some features that define it.</p> <p>Lets take a ball for example. What are the properties of a ball? Its position, radius, colour and velocity</p> <p>Now we have previously drawn one ball in p5 and we defined certain variables to keep track of its position and velocity. We did not save its radius or colour in variables. For creating more complicated animations in the future, we'll need to save all of this information as well.</p> <p>For this purpose, You might try writing code that looks similar to this:</p> <pre><code>var ball_positionX = 5;\nvar ball_positionY = 5;\n\nvar ball_velocityX = 5;\nvar ball_velocityY = 5;\n\nvar ball_colourR = 255;\nvar ball_colourG = 0;\nvar ball_colourB = 0;\n\nvar ball_radius = 40\n\n// and then you want a function to update the position of the ball based on its velocity:\n\nfunction move(posX, posY, velX, velY) {\nreturn [posX + velX, posY + velY]\n}\n\n[ball_positionX, ball_positionY] = move(ball_positonX, ball_positonY, ball_velocityX, ball_velocityY)\n</code></pre> <p>While, this would work for one ball, but some questions one might have are:</p> <ol> <li>What if you wanted to make an unknown number of balls? How would someone know how many variables to declare?</li> <li>What if you had a more complicated object with 100 properties? Would it be feasable to manually declare 100 variables for every object that you might need to create?</li> </ol> <p>This is where classes and object oriented programming come into the picture. You can use classes to define objects that can have properties (like position, colour, velocity, radius) and functions (like move) that operate on and can modify those properties</p>"},{"location":"day1/objects/#52-classes","title":"5.2. Classes","text":"<p>Classes are the tool in programming that allow us to create complicated objects effectively using code.</p> <p>A class is basically a blue-print for creating an object, it tells us the defining properties of the object, and it also tells us what functions the object can perform. Following the class blue-print allows us to create \"instances\" of that class.</p> <p>An object of a class, the realisation of the blueprint, is known as an instance of the class.</p> <p>With this in mind, lets create a ball class in JavaScript that we can use in our p5 sketch!</p>"},{"location":"day1/objects/#53-what-makes-classes-so-good","title":"5.3. What makes classes so good?","text":"<ol> <li>Reusability: The same class can be used to make as many objects as you want</li> <li>Modularity: The code becomes incredibly modular, and it is easy for a programmer to debug the code in case there are any bugs</li> <li>Clarity of code: Due to the code being modular, it is easier for others to read and understand the code</li> <li>Better organisation: The data can be clearly and neatly organised for more complex objects</li> <li> <p>Data Abstraction: This is the process of hiding the implementation details from the user, allowing them to focus on the functionality instead.</p> <p>Example: you don't need to know a smartphone works internally to be able to use it. The details about its circuits, its workings are hidden from you, the user! Instead, the smartphone provides you with functions (call, message, surf the internet) only.</p> </li> </ol>"},{"location":"day1/p5_basics/","title":"2. Basics of p5","text":""},{"location":"day1/p5_basics/#21-setup","title":"2.1. Setup","text":"<p>There are a few different ways to work with p5:</p> <ol> <li>Using the online p5 editor</li> <li>Making a local p5.js project on your computer. You can code with the IDE of your choice</li> </ol> <p>Some useful plugins for VSC:</p> <ol> <li>p5 Resources</li> <li>p5.vscode</li> </ol>"},{"location":"day1/p5_basics/#22-basic-elements-of-a-sketch","title":"2.2. Basic Elements of a Sketch","text":""},{"location":"day1/p5_basics/#1-the-setup-function","title":"1. The Setup Function","text":"<p>The setup function of a p5 sketch is the first function that is run when the sketch is played. Any code that you want to run before your animation begins should go in this function. The most important thing that this function does (usually) is creating the canvas. It is defined like any other function in javascript:</p> <pre><code>function setup() {\n// run only once code here\n}\n</code></pre>"},{"location":"day1/p5_basics/#2-the-canvas","title":"2. The Canvas","text":"<p>The canvas is the most basic and important element of any p5 sketch. It is our playing field for drawing all the things that we want to draw to the screen. All p5 sketches have a canvas (even if you don't create one yourself, p5 will create one for you with default 100 x 100 dimensions)</p> <p>The following setup function creates a canvas of width <code>400px</code> and height <code>200px</code> and sets a background colour of <code>RGB(255, 0, 255)</code> (purple).</p> <pre><code>function setup() {\ncreateCanvas(400, 200);\nbackground(255, 0, 255);\n}\n</code></pre> <p>Tip</p> <p>If you ever want to access the width and height of your canvas elsewhere in the script, you may think to create your own variables to keep track of them, so that you can easily change them later without having to edit them everywhere in your script. This is extremely good coding practise, and so much so that p5 automatically does this for you! The variables <code>width</code> and <code>height</code> are special variables defined by p5 itself which, as their names imply, contain the size of the canvas in pixels. Such variables (and functions) that are defined by default by p5 are known as built-ins. You'll see more such variables in the future!</p>"},{"location":"day1/p5_basics/#3-the-draw-function","title":"3. The Draw Function","text":"<p>The draw function of a p5 sketch is the second most important function that is used to animate the canvas. This function runs 60 times every second and is responsible for updating the canvas. Without the draw function, you can only draw still images with p5</p> <p>The following code will draw a circle moving across the screen (or does it?):</p> <pre><code>function setup() {\ncreateCanvas(400, 400);\nbackground(200); // a single argument for background specifies the greyscale colour value\n}\nvar centreX = 50;\nvar dx = 2;\nfunction draw() {\n// draw a circle in each loop\ncircle(centreX, 100, 50); // specify the coordinates of the centre of the circle and its radius\n\n// increment the circle's X coordinate\ncentreX+=dx;\n}\n</code></pre> <p>If you just tried that, you probably found out that there was an issue with the animation. The reason is that p5 does not reset the background at each iteration of the draw loop. If you want to do that, you need to do so manually:</p> <pre><code>function setup() {\ncreateCanvas(400, 400);\nbackground(200);\n}\n\nvar centreX = 50;\nvar dx = 2;\nfunction draw() {\n// reset the background in each iteration\nbackground(200);\ncircle(centreX, 100, 50);\ncentreX+=dx;\n}\n</code></pre> Think <p>Currently the circle goes across the screen and passes through the right edge of the canvas. What if we want to make the circle bounce back when it touches the right edge of the canvas?</p> Hint 1 <p>Currently the circle goes across the screen and passes through the right edge of the canvas. What if we want to make the circle bounce back when it touches the right edge of the canvas?</p> <p>Hint 1: We know the width of the canvas, and the circle's X coordinate on the canvas. What can you do with this information?</p> Hint 2 <p>Currently the circle goes across the screen and passes through the right edge of the canvas. What if we want to make the circle bounce back when it touches the right edge of the canvas?</p> <p>Hint 1: We know the width of the canvas, and the circle's X coordinate on the canvas. What can you do with this information?</p> <p>Hint 2: Can you use some sort of conditional logic to change the variable <code>dx</code> when the circle's X coordinate is outside the width of the canvas?</p> Solution <p>Currently the circle goes across the screen and passes through the right edge of the canvas. What if we want to make the circle bounce back when it touches the right edge of the canvas?</p> <p>Hint 1: We know the width of the canvas, and the circle's X coordinate on the canvas. What can you do with this information?</p> <p>Hint 2: Can you use some sort of conditional logic to change the variable <code>dx</code> when the circle's X coordinate is outside the width of the canvas?</p> <pre><code>function setup() {\ncreateCanvas(400, 400);\nbackground(0);\n}\n\nvar centreX = 50;\nvar dx = 2;\nfunction draw() {\nbackground(200);\ncircle(centreX, 100, 50);\n\nif(width &lt; centreX)\ndx = -2;\n\ncentreX+=dx;\n}\n</code></pre> Bonus Question <p>Currently the circle goes across the screen and passes through the right edge of the canvas. What if we want to make the circle bounce back when it touches the right edge of the canvas?</p> <p>Hint 1: We know the width of the canvas, and the circle's X coordinate on the canvas. What can you do with this information?</p> <p>Hint 2: Can you use some sort of conditional logic to change the variable <code>dx</code> when the circle's X coordinate is outside the width of the canvas?</p> <p>Bonus: The code for the solution is not perfect, the circle still goes half-way through the edge before it bounces back, and also it still passes through the left edge of the canvas without bouncing. How can we address both of these issues?</p> Bonus Solution <p>Currently the circle goes across the screen and passes through the right edge of the canvas. What if we want to make the circle bounce back when it touches the right edge of the canvas?</p> <p>Hint 1: We know the width of the canvas, and the circle's X coordinate on the canvas. What can you do with this information?</p> <p>Hint 2: Can you use some sort of conditional logic to change the variable <code>dx</code> when the circle's X coordinate is outside the width of the canvas?</p> <p>Bonus: The code for the solution is not perfect, the circle still goes half-way through the edge before it bounces back, and also it still passes through the left edge of the canvas without bouncing. How can we address both of these issues?</p> <pre><code>function setup() {\ncreateCanvas(400, 400);\nbackground(0);\n}\n\nvar centreX = 50;\nvar dx = 2;\nfunction draw() {\nbackground(200);\ncircle(centreX, 100, 50);\n\nif(centreX-25 &lt; 0 || width &lt; centreX+25)\ndx *= -1;\n\ncentreX+=dx;\n}\n</code></pre>"},{"location":"day1/p5_basics/#23-p5-reference","title":"2.3. p5 Reference","text":"<p>What if you want to draw more shapes than just a circle? There are more functions that you can use to draw shapes in p5, but we need some way to find out the syntax of each function to be able to use them. This is what the p5 reference is for. The reference contains the information about each and every p5 built-in function, variable and more.</p>"},{"location":"day2/events/","title":"4. Events","text":""},{"location":"day2/events/#41-what-are-events","title":"4.1. What are Events?","text":"<p>Lets say that you want to change the background of the canvas to a random colour everytime someone left clicks. How would you go about doing this? This is where events come in. Events are special actions or occurances that are recognised by the software/framework/library that you're working with. With every event, there is a corresponding function that is called when that event occurs.</p>"},{"location":"day2/events/#42-detecting-and-identifying-mouse-clicks","title":"4.2. Detecting and Identifying Mouse Clicks","text":"<p>When you click with your mouse, the <code>mousePressed()</code> function is called, the built-in boolean variable <code>mouseIsPressed</code> is set to <code>true</code> and the variable <code>mouseButton</code> is set to whatever button was pressed on the mouse. It can be one of three different values, <code>LEFT</code>, <code>RIGHT</code>, or <code>MIDDLE</code></p> <p>This is how we can use this function to set the background to a random colour everytime someone left clicks:</p> <pre><code>function mousePressed() {\nif(mouseButton === LEFT) {\nvar r = random(256);\nvar g = random(256);\nvar b = random(256);\n\nbackground(r, g, b);\n}\n}\n</code></pre> <p>There are similar functions and variables for events related to keyboard and touch input. You can find out more about them by looking through the reference!</p>"},{"location":"day2/intersections/","title":"6. Overlapping Shapes","text":""},{"location":"day2/intersections/#61-determining-if-a-point-is-inside-a-given-shape","title":"6.1. Determining If A Point Is Inside A Given Shape","text":""},{"location":"day2/intersections/#1-circles","title":"1. Circles","text":"<p>Determining if a point lies inside a circle is simple. We just check the distance of the point from the centre of the circle. If it is greater than the radius of the circle, then the point lies outside the circle. This simple sketch demonstrates this:</p> <pre><code>let circ = {\nx: 150,\ny: 150,\nr: 100\n};\nfunction setup() {\ncreateCanvas(400, 400);\nbackground(200);\n}\nfunction draw() {\nbackground(200);\nif(dist(circ.x, circ.y, mouseX, mouseY) &lt;= circ.r)\nfill(255, 0, 0);\nelse\nfill(255);\ncircle(circ.x, circ.y, 2*circ.r);\n}\n</code></pre>"},{"location":"day2/intersections/#2-rectangles-and-squares","title":"2. Rectangles and Squares","text":"<p>Determining if a point lies inside a rectangle (or a square) is also fairly straightforward. If the X and Y coordinates of the point lie between the X and Y coordinates for two opposite corners of the rectangle, then the point lies inside the rectangle. The following sketch demonstrates this:</p> <pre><code>let rec = {\nx1: 150,\ny1: 100,\nx2: 300,\ny2: 350,\n};\nfunction setup() {\ncreateCanvas(400, 400);\nbackground(200);\n}\nfunction draw() {\nbackground(200);\nif(rec.x1 &lt; mouseX &amp;&amp; mouseX &lt; rec.x2 &amp;&amp; rec.y1 &lt; mouseY &amp;&amp; mouseY &lt; rec.y2)\nfill(255, 0, 0);\nelse\nfill(255);\nrect(rec.x1, rec.y1, rec.x2-rec.x1, rec.y2-rec.y1);\n}\n</code></pre>"},{"location":"day2/intersections/#3-any-general-shape","title":"3. Any General Shape","text":"<p>To check if a point lies within any general shape, you draw a line from the point towards the right till the edge of the canvas, and if this line intersects an even number of edges, then the point is outside the shape, otherwise it is inside the shape. The following code demonstrates this:</p> <pre><code>function setup() {\ncreateCanvas(400, 400);\nbackground(200);\n}\nfunction pentagon(x, y, edge) {\nlet radius = sin(radians(54))/sin(radians(72))*edge;\nlet vertices = [];\n\n\nbeginShape();\nfor(i = 0; i &lt; 5; ++i) {\nvertex(x + radius*cos(2*PI*i/5), y + radius*sin(2*PI*i/5));\nvertices.push({x: x + radius*cos(2*PI*i/5), y: y + radius*sin(2*PI*i/5)});\n}\nendShape(CLOSE);\nreturn vertices;\n}\nfunction draw() {\nbackground(200);\n\nlet vertices = pentagon(100, 100, 50);\nlet outside = true;\nlet n = vertices.length;\n\nfor(let i = 0; i &lt; n; ++i) {\nlet interX = (mouseY-vertices[i].y)*(vertices[i].x-vertices[(i+1)%n].x)/(vertices[i].y-vertices[(i+1)%n].y) + vertices[i].x;\nlet minX = Math.min(vertices[i].x, vertices[(i+1)%n].x);\nlet maxX = Math.max(vertices[i].x, vertices[(i+1)%n].x);\nlet minY = Math.min(vertices[i].y, vertices[(i+1)%n].y);\nlet maxY = Math.max(vertices[i].y, vertices[(i+1)%n].y);\nif(mouseX &lt;= interX &amp;&amp; minX &lt;= interX &amp;&amp; interX &lt;= maxX &amp;&amp; minY &lt;= mouseY &amp;&amp; mouseY &lt;= maxY)\noutside = !outside;\n}\n\nif(outside)\nfill(255);\nelse\nfill(255, 0, 0);\n}\n</code></pre>"},{"location":"day2/intersections/#62-determining-if-two-shapes-overlap","title":"6.2. Determining If Two Shapes Overlap","text":""},{"location":"day2/intersections/#1-circles_1","title":"1. Circles","text":"<p>Determining if two circles overlap is simple. If the distance between their centres is less than the sum of their radii then they overlap.</p> <pre><code>let circ = {\nx: 150,\ny: 150,\nr: 100\n};\nlet r2 = 50;\nfunction setup() {\ncreateCanvas(400, 400);\nbackground(200);\n}\nfunction draw() {\nbackground(200);\nif(dist(circ.x, circ.y, mouseX, mouseY) &lt;= circ.r+r2)\nfill(255, 0, 0);\nelse\nfill(255);\n\ncircle(circ.x, circ.y, 2*circ.r);\ncircle(mouseX, mouseY, 2*r2);\n}\n</code></pre>"},{"location":"day2/intersections/#2-rectangles","title":"2. Rectangles","text":"<p>Determining if two rectangles overlap is also fairly simple. If the manhattan distance between their centres is less than half the sum of their length and widths.</p> <pre><code>let rec = {\nx: 150,\ny: 100,\nw: 100,\nh: 50,\n};\nlet rec2 = {\nw: 50,\nh: 100,\n};\n\nfunction setup() {\ncreateCanvas(400, 400);\nbackground(200);\n}\n\nfunction mdist(x1, y1, x2, y2) {\nreturn Math.abs(x2-x1) + Math.abs(y2-y1);\n}\n\nfunction draw() {\nbackground(200);\nif(Math.abs(mouseX-rec.x) &lt; (rec.w+rec2.w)/2 &amp;&amp; Math.abs(mouseY-rec.y) &lt; (rec.h+rec2.h)/2)\nfill(255, 0, 0);\nelse\nfill(255);\nrect(rec.x-rec.w/2, rec.y-rec.h/2, rec.w, rec.h);\nrect(mouseX-rec2.w/2, mouseY-rec2.h/2, rec2.w, rec2.h);\n} </code></pre>"},{"location":"day2/shapes/","title":"Shapes","text":""},{"location":"day2/shapes/#31-activity-10-minutes","title":"3.1. Activity (10 Minutes)","text":"<p>Using google search or the p5 reference, find out how to do the following:</p> <ol> <li>Draw a rectangle</li> <li>Draw a point</li> <li>Draw a line joining two points</li> <li>Draw a square</li> <li>Draw a triangle</li> <li>Draw an ellipse</li> </ol>"},{"location":"day2/shapes/#32-stroke-and-fill-options","title":"3.2. Stroke and Fill Options","text":"<p>To change the colour of the outline (stroke) of a shape, we can use the <code>stroke()</code> function. As you may guess, this function accepts an RGB or Greyscale value as an input:</p> <p><code>stroke(255);</code> changes the stroke to white.</p> <p><code>stroke(255, 255, 0);</code> changes the stroke to yellow.</p> <p>Additionally, you can also specify an alpha value along with the RGB or Greyscale values:</p> <p><code>stroke(255, 127);</code> changes the stroke to a half transparent white.</p> <p><code>stroke(255, 255, 0, 255);</code> changes the stroke to a fully opaque yellow.</p> <p>If you don't want to have an outline at all, you can use <code>noStroke();</code></p> <p>To change the colour of the fill of a shape, we can use the <code>fill()</code> function. Its arguments work exactly the same as the stroke function. If you don't want to have a fill for your shape, you can use <code>noFill();</code></p> <p>Note that these functions must be called BEFORE you draw the shapes for which you want them to apply. Also note that once the stroke is changed, it will remain that way until changed again.</p> <p>There are many more functions that can change the way that shapes are drawn, you do not need to memorise all of their syntaxes, but just need to know how to look them up in the reference (or even search on google) for them when you need to use them. As an exercise, can you find the function that changes the thickness of the outline of shapes in the reference?</p>"},{"location":"day2/shapes/#33-custom-shapes","title":"3.3. Custom Shapes","text":"<p>What if you want to make a shape that does not have a built-in function in p5? For this purpose, p5 lets us define custom shapes very simply using three functions called <code>beginShape()</code>, <code>vertex()</code>, <code>endShape()</code></p> <p>Lets say that you want to create pentagons. The following function can be used to do so:</p> <pre><code>function pentagon(x, y, edge) {\nlet radius = sin(radians(54))/sin(radians(72))*edge;\nbeginShape()\nfor(i = 0; i &lt; 5; ++i)\nvertex(x + radius*cos(2*PI*i/5), y + radius*sin(2*PI*i/5))\nendShape()\n}\n</code></pre> <p>Now you may notice, that one of the edges of the pentagon is missing. This is because the shape is not closed by default. The missing edge is the one that should be drawn between the first vertex and the last vertex. To make the shape closed, we can pass in the constant <code>CLOSE</code> as an argument to the <code>endShape</code> function.</p> <pre><code>function pentagon(x, y, edge) {\nlet radius = sin(radians(54))/sin(radians(72))*edge;\n\nbeginShape()\nfor(i = 0; i &lt; 5; ++i)\nvertex(x + radius*cos(2*PI*i/5), y + radius*sin(2*PI*i/5))\nendShape(CLOSE)\n}\n</code></pre>"},{"location":"day2/shapes/#34-transformations","title":"3.4. Transformations","text":"<p>Now you might also notice that the pentagon is not \"flat\". It is currently slightly rotated. This issue can be fixed by using an anti clock wise rotation.</p> <pre><code>function pentagon(x, y, edge) {\nlet radius = sin(radians(54))/sin(radians(72))*edge;\n\nrotate(radians(-18));\n\nbeginShape()\nfor(i = 0; i &lt; 5; ++i)\nvertex(x + radius*cos(2*PI*i/5), y + radius*sin(2*PI*i/5))\nendShape(CLOSE)\n}\n</code></pre> <p>Now you may note that after doing the rotation, the pentagon is no longer correctly centred. The reason for this is that the rotation happens around the origin of the canvas (which is at the top left). This means that anything drawn at a given (x, y) is first rotated anti clockwise by 18 degrees around (0, 0) before being displayed on the canvas.</p> <p>For the pentagon to be centred correctly, we need to rotate about the centre of the pentagon, and not the origin. For this, we can make use of the <code>translate()</code> function. This function moves the origin to the specified coordinates (x, y)</p> <pre><code>function pentagon(x, y, edge) {\nlet radius = sin(radians(54))/sin(radians(72))*edge;\n\ntranslate(x, y);\nrotate(radians(-18));\n\nbeginShape()\nfor(i = 0; i &lt; 5; ++i)\nvertex(radius*cos(2*PI*i/5), radius*sin(2*PI*i/5))\nendShape(CLOSE)\n}\n</code></pre> <p>You may have also noticed that if you now try to make another shape, its rotation is not correct either! The reason for this is that just like <code>stroke()</code>, changes made by functions like <code>rotate()</code> and <code>translate()</code> are also settings that need to be changed manually. More formally, these rotations and translations are known as linear transformations. To fix our shape situation, one option is to reverse all the transformations that we make.</p> <pre><code>function pentagon(x, y, edge) {\nlet radius = sin(radians(54))/sin(radians(72))*edge;\n\ntranslate(x, y);\nrotate(radians(-18));\n\nbeginShape()\nfor(i = 0; i &lt; 5; ++i)\nvertex(radius*cos(2*PI*i/5), radius*sin(2*PI*i/5))\nendShape(CLOSE)\n\nrotate(radians(18));\ntranslate(-x, -y);\n}\n</code></pre> <p>While this works, this is not very manage-able in the long run if you make hundreds or thousands of transformations in your sketch, you simply can't keep track of them all to reverse them. Even if you could keep track, it would take time and computational power to reverse them. Due to these reasons, p5 offers us a way to save the current transformation settings by using <code>push()</code> function. They can then be restored by using the <code>pop</code> function.</p> <pre><code>function pentagon(x, y, edge) {\nlet radius = sin(radians(54))/sin(radians(72))*edge;\n\npush();\n\ntranslate(x, y);\nrotate(radians(-18));\n\nbeginShape()\nfor(i = 0; i &lt; 5; ++i)\nvertex(radius*cos(2*PI*i/5), radius*sin(2*PI*i/5))\nendShape(CLOSE)\n\npop();\n}\n</code></pre> <p>Note: while <code>push()</code> and <code>pop()</code> are mainly used to save and restore transformation settings, they also save and restore ANY other settings for the canvas like stroke and fill.</p>"}]}